-- 3.DB구성정보 - 가. 현행 데이터베이스 전체 용량
SELECT MAX((SELECT MAX(NAME) FROM V$DATABASE)) AS "DB명"
     , ROUND(SUM(B.GB), 2) AS "전체용량(GB)"
     , ROUND(SUM(C.GB), 2) AS "사용량(GB)"
	 , TO_CHAR(ROUND(SUM(C.GB)/SUM(B.GB), 4) * 100,'fm990D00','NLS_NUMERIC_CHARACTERS = ''.,''') || '%' AS "사용률(%)"
  FROM DBA_TABLESPACES A
     , (SELECT TABLESPACE_NAME
             , SUM(BYTES/1024/1024/1024) AS GB
             , AUTOEXTENSIBLE
          FROM DBA_DATA_FILES
         GROUP BY TABLESPACE_NAME, AUTOEXTENSIBLE) B
     , (SELECT TABLESPACE_NAME
             , SUM(BYTES/1024/1024/1024) AS GB
          FROM DBA_SEGMENTS
         GROUP BY TABLESPACE_NAME) C
 WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME (+)
   AND B.TABLESPACE_NAME = C.TABLESPACE_NAME (+)
   AND A.TABLESPACE_NAME NOT IN (SELECT TABLESPACE_NAME FROM DBA_TEMP_FILES)
 ORDER BY 1;

-- 3.DB구성정보 - 나. 현행 데이터베이스 SGA 구성 정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , (SELECT MAX(INSTANCE) FROM V$THREAD) AS "SID"
     , NAME AS "파라미터"
     , VALUE AS "값"
  FROM V$SGA
 ORDER BY 1,2,3;

-- 4.DB컴포넌트정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , COMP_ID AS "컴포넌트ID"
     , COMP_NAME AS "컴포넌트명"
     -- , VERSION_FULL AS "버전"
     , VERSION AS "버전"
     , STATUS AS "상태"
     , SCHEMA
  FROM DBA_REGISTRY
 ORDER BY 1,3;

-- 5.DB파라미터구성현황
SELECT DESCRIPTION AS "구분"
     , NAME AS "파라미터"
	 , VALUE
  FROM V$PARAMETER
 ORDER BY NAME;

-- 6.DBFILE구성정보 (CONTROL FILE)
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , NAME AS "파일명"
  FROM V$CONTROLFILE;

-- 6.DBFILE구성정보 (REDOLOG FILE)
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.THREAD# AS "THREAD"
     , B.GROUP# AS "GROUP"
     , B.MEMBER AS "파일명"
     , A.BYTES/1024/1024 AS "SIZE(MB)"
  FROM V$LOG A
     , V$LOGFILE B
 WHERE A.GROUP# = B.GROUP#
 ORDER BY 3,4;;
 
-- 6.DBFILE구성정보 (DATAFILE)
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , TABLESPACE_NAME AS "테이블스페이스명"
     , FILE_ID AS "FILE ID"
     , FILE_NAME AS "FILE 명"
     , BYTES/1024/1024 AS "SIZE(MB)"
     , STATUS
     , ONLINE_STATUS AS "ONLINE STATUS"
     , AUTOEXTENSIBLE AS "자동증가여부"
     , MAXBYTES AS "MXBYTES"
  FROM DBA_DATA_FILES
 ORDER BY FILE_ID;

-- 7.테이블스페이스구성정보
-- ORANGE 기준 테이블스페이스 조회
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.TABLESPACE_NAME AS "테이블스페이스명"
     , A.BLOCK_SIZE AS "BLOCK SIZE"
     , A.STATUS AS "상태"
     , A.EXTENT_MANAGEMENT AS "EXTENT MANAGEMENT"
     , A.ALLOCATION_TYPE AS "ALLOCATION TYPE"
     , A.SEGMENT_SPACE_MANAGEMENT AS "SEGMENT SPACE MANAGEMENT"
     , NVL(D.CNT,0) AS "SEGMENT COUNT"
     , NVL(ROUND((B.DF_TOTAL_BYTES - C.DF_FREE_BYTES) / 1024/1024, 2), 0) AS "USED SIZE(GB)" -- 데이터 파일 기준
     , NVL(ROUND(B.DF_TOTAL_BYTES / 1024/1024/1024, 2), 0) AS "TOTAL SIZE(GB)"                    -- 데이터 파일 기준
     , NVL(ROUND(C.DF_FREE_BYTES / 1024/1024/1024, 2), 0) AS "FREE SIZE(GB)"                      -- 데이터 파일 기준
     --, NVL(ROUND(D.SG_USED_BYTES / 1024/1024/1024, 2), 0) AS "SEGMENT TOTAL SIZE(GB)"             -- 세그먼트 기준
     , NVL(ROUND((B.DF_TOTAL_BYTES - C.DF_FREE_BYTES) / B.DF_TOTAL_BYTES * 100, 2), 0) AS "사용률(%)"
  FROM DBA_TABLESPACES A
     , (SELECT TABLESPACE_NAME, SUM(BYTES) AS "DF_TOTAL_BYTES" FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME) B
     , (SELECT TABLESPACE_NAME, SUM(BYTES) AS "DF_FREE_BYTES"  FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME) C
     , (SELECT TABLESPACE_NAME, COUNT(*) AS CNT, SUM(BYTES) AS "SG_USED_BYTES" FROM DBA_SEGMENTS GROUP BY TABLESPACE_NAME) D
 WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME
   AND B.TABLESPACE_NAME = C.TABLESPACE_NAME (+)
   AND A.TABLESPACE_NAME = D.TABLESPACE_NAME (+)
 ORDER BY A.TABLESPACE_NAME;

-- DBEAVER 기준 테이블스페이스 조회
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.TABLESPACE_NAME AS "테이블스페이스명"
     , A.BLOCK_SIZE AS "BLOCK SIZE"
     , A.STATUS AS "상태"
     , A.EXTENT_MANAGEMENT AS "EXTENT MANAGEMENT"
     , A.ALLOCATION_TYPE AS "ALLOCATION TYPE"
     , A.SEGMENT_SPACE_MANAGEMENT AS "SEGMENT SPACE MANAGEMENT"
     , NVL(C.CNT, 0) AS "SEGMENT COUNT"
     , NVL(ROUND(C.BYTES/1024/1024/1024, 2), 0) AS "USED SIZE(GB)"
     , NVL(ROUND(B.BYTES/1024/1024/1024, 2), 0) AS "TOTAL SIZE(GB)"
     , NVL(ROUND((B.BYTES - C.BYTES)/1024/1024/1024, 2), 0) AS "FREE SIZE(GB)"
     , NVL(ROUND(C.BYTES/B.BYTES * 100, 2), 0) AS "사용률(%)"
  FROM DBA_TABLESPACES A
     , (SELECT TABLESPACE_NAME
             , SUM(BYTES) AS BYTES
          FROM DBA_DATA_FILES
         GROUP BY TABLESPACE_NAME) B
     , (SELECT TABLESPACE_NAME
             , COUNT(*) AS CNT
             , SUM(BYTES) AS BYTES
          FROM DBA_SEGMENTS
         GROUP BY TABLESPACE_NAME) C
 WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME (+)
   AND B.TABLESPACE_NAME = C.TABLESPACE_NAME (+)
   AND A.TABLESPACE_NAME NOT IN (SELECT TABLESPACE_NAME FROM DBA_TEMP_FILES)
 ORDER BY A.TABLESPACE_NAME;





-- 8.DB유저및시스템권한정보 - 가. 전체 유저 정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.USERNAME AS "유저명"
     , A.ACCOUNT_STATUS AS "상태"
     , A.LOCK_DATE AS "LOCK DATE"
     , A.EXPIRY_DATE AS "EXPIRY DATE"
     , A.DEFAULT_TABLESPACE AS "DEFAULT TABLESPACE"
     , A.TEMPORARY_TABLESPACE AS "TEMPORARY TABLESPACE"
     , A.CREATED AS "생성일자"
     , A.PROFILE
     -- , LISTAGG(B.GRANTED_ROLE, ', ') WITHIN GROUP (ORDER BY B.GRANTED_ROLE) AS "GRANTED ROLES"
	 -- , WM_CONCAT(B.GRANTED_ROLE) AS "GRANTED ROLES"
  FROM DBA_USERS A
     , DBA_ROLE_PRIVS B
 WHERE A.USERNAME = B.GRANTEE
   -- AND A.USERNAME NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 -- GROUP BY A.USERNAME, A.ACCOUNT_STATUS, A.LOCK_DATE, A.EXPIRY_DATE, A.DEFAULT_TABLESPACE, A.TEMPORARY_TABLESPACE, A.CREATED, A.PROFILE
 ORDER BY A.USERNAME;

-- 8.DB유저및시스템권한정보 - 나. 사용자 유저 시스템권한 정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , GRANTEE AS "유저명"
     , PRIVILEGE AS "시스템권한"
  FROM DBA_SYS_PRIVS
 WHERE 1=1
   -- AND GRANTEE NOT IN (SELECT ROLE FROM DBA_ROLES WHERE ORACLE_MAINTAINED = 'Y')
   -- AND GRANTEE NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
   AND ADMIN_OPTION = 'NO';

-- 8.DB유저및시스템권한정보 - 다. 사용자 유저에 부여된 ROLE 정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , GRANTEE AS "유저명"
     , GRANTED_ROLE AS "시스템권한"
  FROM DBA_ROLE_PRIVS;

-- 9.PROFILE정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , PROFILE AS "프로파일명"
     , RESOURCE_NAME AS "리소스명"
     , RESOURCE_TYPE AS "리소스 타입"
     , LIMIT
  FROM DBA_PROFILES
 ORDER BY PROFILE, RESOURCE_NAME;

-- 10.테이블정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.OWNER
     , A.TABLE_NAME AS "테이블명(영문)"
     , B.COMMENTS AS "테이블명(한글)"
     , A.TABLESPACE_NAME AS "테이블스페이스"
     , A.PARTITIONED AS "파티션여부"
     , A.LAST_ANALYZED AS "마지막 통계정보"
     , A.NUM_ROWS AS "DATA건수"
     , C.BYTES/1024/1024 AS "SIZE(MB)"
  FROM DBA_TABLES A
     , DBA_TAB_COMMENTS B
     , DBA_SEGMENTS C
 WHERE A.TABLE_NAME = B.TABLE_NAME
   AND A.OWNER = B.OWNER
   AND A.TABLE_NAME = C.SEGMENT_NAME
   AND A.OWNER = C.OWNER
   -- AND A.OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY A.OWNER, A.TABLE_NAME;

-- 11.파티션테이블정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.OWNER
     , A.TABLE_NAME AS "테이블명(한글)"
     , B.COMMENTS AS "테이블명(영어)"
     , A.PARTITIONING_TYPE 
     , A.SUBPARTITIONING_TYPE
     , A.PARTITION_COUNT
     , A.SUBPARTITIONING_KEY_COUNT
     , A.PARTITIONING_KEY_COUNT
     , NULL AS "파티션주기"
     , NULL AS "보관주기"
     , D.PARTITION_NAME
  FROM DBA_PART_TABLES A
     , DBA_TAB_COMMENTS B
     , (SELECT TABLE_OWNER
             , TABLE_NAME
             , MAX(PARTITION_POSITION) AS MAX_PARTITION_POSITION
          FROM DBA_TAB_PARTITIONS
         GROUP BY TABLE_OWNER, TABLE_NAME) C
     , DBA_TAB_PARTITIONS D
 WHERE A.TABLE_NAME = B.TABLE_NAME
   AND A.OWNER = B.OWNER
   AND A.TABLE_NAME = C.TABLE_NAME
   AND A.OWNER = C.TABLE_OWNER
   AND A.TABLE_NAME = D.TABLE_NAME
   AND A.OWNER = D.TABLE_OWNER
   AND C.MAX_PARTITION_POSITION = D.PARTITION_POSITION
   -- AND A.OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY A.OWNER, A.TABLE_NAME;

-- 12.인덱스정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER AS "INDEX OWNER"
     , INDEX_NAME AS "인덱스명"
     , INDEX_TYPE AS "INDEX TYPE"
     , TABLE_OWNER AS "TABLE OWNER"
     , TABLE_NAME AS "테이블명"
     , TABLESPACE_NAME AS "테이블스페이스명"
     , LOGGING AS "로깅여부"
     , STATUS AS "상태"
     , LAST_ANALYZED AS "마지막 통계정보"
     , PARTITIONED AS "파티션여부"
     , DEGREE AS "병렬수"
  FROM DBA_INDEXES
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
   AND INDEX_TYPE <> 'LOB'
 ORDER BY OWNER, INDEX_NAME;

-- 13.LOB정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER
     , TABLE_NAME AS "테이블명"
     , COLUMN_NAME AS "컬럼명"
     , SEGMENT_NAME AS "LOB명"
     , TABLESPACE_NAME AS "테이블스페이스명"
     , INDEX_NAME AS "인덱스명"
     , CHUNK AS "CHUNK SIZE"
     , LOGGING AS "로깅여부"
     , PARTITIONED AS "파티션여부"
  FROM DBA_LOBS
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY OWNER, TABLE_NAME;

-- 14.제약조건(PK,FK)정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.OWNER
     , A.CONSTRAINT_NAME AS "제약조건명"
     , A.CONSTRAINT_TYPE AS "제약조건 타입"
     , A.TABLE_NAME AS "테이블명"
     , A.R_OWNER AS "참조 OWNER"
     , A.R_CONSTRAINT_NAME AS "참조 제약조건명"
     , B.TABLE_NAME AS "참조 테이블명"
     , A.STATUS AS "상태"
     , A.VALIDATED
  FROM DBA_CONSTRAINTS A
     , DBA_CONSTRAINTS B
 WHERE A.R_OWNER = B.OWNER
   AND A.R_CONSTRAINT_NAME = B.CONSTRAINT_NAME
   -- AND A.OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY A.OWNER, A.CONSTRAINT_NAME;

-- 15.트리거정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER
     , TRIGGER_NAME AS "트리거명"
     , TRIGGER_TYPE AS "트리거 타입"
     , TRIGGERING_EVENT AS "트리거 이벤트"
     , TABLE_OWNER AS "테이블 OWNER"
     , TABLE_NAME AS "테이블명"
     , STATUS AS "상태"
  FROM DBA_TRIGGERS
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY OWNER, TRIGGER_NAME;

-- 16.시퀀스정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , SEQUENCE_OWNER AS "OWNER"
     , SEQUENCE_NAME AS "시퀀스명"
     , MIN_VALUE AS "초기값"
     , MAX_VALUE AS "최대값"
     , INCREMENT_BY AS "증가범위"
     , CYCLE_FLAG AS "재사용 여부"
     , ORDER_FLAG AS "ORDER 여부"
     , CACHE_SIZE AS "CACHE SIZE"
     , LAST_NUMBER AS "LAST NUMBER"
  FROM DBA_SEQUENCES
 WHERE 1=1
   -- AND SEQUENCE_OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY SEQUENCE_OWNER, SEQUENCE_NAME;

-- 17.오브젝트정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER
     , OBJECT_NAME AS "오브젝트명"
     , OBJECT_TYPE AS "오브젝트 타입"
     , CREATED AS "생성일자"
     , LAST_DDL_TIME AS "마지막 변경일자"
     , STATUS AS "상태"
  FROM DBA_OBJECTS
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
   AND OBJECT_TYPE <> 'SYNONYM'
 ORDER BY OWNER, OBJECT_NAME;

-- 18.MVIEW정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER
     , MVIEW_NAME AS "MVIEW명"
     , REFRESH_MODE AS "REFRESH MODE"
     , REFRESH_METHOD AS "REFRESH METHOD"
     , LAST_REFRESH_TYPE AS "LAST REFRESH TYPE"
     , LAST_REFRESH_DATE AS "LAST REFRESH DATE"
  FROM DBA_MVIEWS
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY OWNER, MVIEW_NAME;

-- 19.DBLINK정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , OWNER
     , DB_LINK AS "DBLINK명"
     , USERNAME AS "유저명"
     , HOST
     , CREATED AS "생성일자"
  FROM DBA_DB_LINKS
 WHERE 1=1
   -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY OWNER, DB_LINK;

-- 20.JOB SCHEDULER정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , JOB AS "JOB NO"
     , SCHEMA_USER AS "SCHEMA USER"
     , LAST_DATE AS "LAST DATE"
     , LAST_SEC AS "LAST SEC"
     , NEXT_DATE AS "NEXT DATE"
     , NEXT_SEC AS "NEXT SEC"
     , TOTAL_TIME AS "TOTAL TIME"
     , BROKEN AS "BROKEN"
     , INTERVAL
     , FAILURES
     , WHAT
     , NLS_ENV
  FROM DBA_JOBS
 ORDER BY 2,3;

-- 20.JOB SCHEDULER정보 - crontab (서버 터미널에서 아래 명령어 수행)
crontab -l

-- 21.유저별오브젝트수
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.OWNER
     , COUNT(TABLE_STAT_VAL) AS TABLE_VAL
     , COUNT(TABLE_STAT_INVAL) AS TABLE_INVAL
     , COUNT(INDEX_STAT_VAL) AS INDEX_VAL
     , COUNT(INDEX_STAT_INVAL) AS INDEX_INVAL
     , COUNT(VIEW_STAT_VAL) AS VIEW_VAL
     , COUNT(VIEW_STAT_INVAL) AS VIEW_INVAL
     , COUNT(SYNONYM_STAT_VAL) AS SYNONYM_VAL
     , COUNT(SYNONYM_STAT_INVAL) AS SYNONYM_INVAL
     , COUNT(SEQUENCE_STAT_VAL) AS SEQUENCE_VAL
     , COUNT(SEQUENCE_STAT_INVAL) AS SEQUENCE_INVAL
     , COUNT(FUNCTION_STAT_VAL) AS FUNCTION_VAL
     , COUNT(FUNCTION_STAT_INVAL) AS FUNCTION_INVAL
     , COUNT(PROCEDURE_STAT_VAL) AS PROCEDURE_VAL
     , COUNT(PROCEDURE_STAT_INVAL) AS PROCEDURE_INVAL
     , COUNT(PACKAGE_STAT_VAL) AS PACKAGE_VAL
     , COUNT(PACKAGE_STAT_INVAL) AS PACKAGE_INVAL
     , COUNT(PACKAGE_BODY_STAT_VAL) AS PACKAGE_BODY_VAL
     , COUNT(PACKAGE_BODY_STAT_INVAL) AS PACKAGE_BODY_INVAL
     , COUNT(LOB_STAT_VAL) AS LOB_VAL
     , COUNT(LOB_STAT_INVAL) AS LOB_INVAL
     , COUNT(TRIGGER_STAT_VAL) AS TRIGGER_VAL
     , COUNT(TRIGGER_STAT_INVAL) AS TRIGGER_INVAL
     , COUNT(DBLINK_STAT_VAL) AS DBLINK_VAL
     , COUNT(DBLINK_STAT_INVAL) AS DBLINK_INVAL
     , COUNT(MVIEW_STAT_VAL) AS MVIEW_VAL
     , COUNT(MVIEW_STAT_INVAL) AS MVIEW_INVAL
     , COUNT(TABLE_PART_STAT_VAL) AS TABLE_PART_VAL
     , COUNT(TABLE_PART_STAT_INVAL) AS TABLE_PART_INVAL
     , COUNT(INDEX_PART_STAT_VAL) AS INDEX_PART_VAL
     , COUNT(INDEX_PART_STAT_INVAL) AS INDEX_PART_INVAL
     , COUNT(LOB_PART_STAT_VAL) AS LOB_PART_VAL
     , COUNT(LOB_PART_STAT_INVAL) AS LOB_PART_INVAL
     , COUNT(TABLE_SUBPART_STAT_VAL) AS TABLE_SUBPART_VAL
     , COUNT(TABLE_SUBPART_STAT_INVAL) AS TABLE_SUBPART_INVAL
     , COUNT(INDEX_SUBPART_STAT_VAL) AS INDEX_SUBPART_VAL
     , COUNT(INDEX_SUBPART_STAT_INVAL) AS INDEX_SUBPART_INVAL
  FROM (
        SELECT OBJECT_TYPE
             , OWNER
             , OBJECT_NAME
             , CASE WHEN OBJECT_TYPE = 'TABLE' AND STATUS = 'VALID' THEN STATUS END AS TABLE_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'TABLE' AND STATUS = 'INVALID' THEN STATUS END AS TABLE_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'INDEX' AND STATUS = 'VALID' THEN STATUS END AS INDEX_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'INDEX' AND STATUS = 'INVALID' THEN STATUS END AS INDEX_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'VIEW' AND STATUS = 'VALID' THEN STATUS END AS VIEW_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'VIEW' AND STATUS = 'INVALID' THEN STATUS END AS VIEW_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'SYNONYM' AND STATUS = 'VALID' THEN STATUS END AS SYNONYM_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'SYNONYM' AND STATUS = 'INVALID' THEN STATUS END AS SYNONYM_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'SEQUENCE' AND STATUS = 'VALID' THEN STATUS END AS SEQUENCE_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'SEQUENCE' AND STATUS = 'INVALID' THEN STATUS END AS SEQUENCE_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'FUNCTION' AND STATUS = 'VALID' THEN STATUS END AS FUNCTION_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'FUNCTION' AND STATUS = 'INVALID' THEN STATUS END AS FUNCTION_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'PROCEDURE' AND STATUS = 'VALID' THEN STATUS END AS PROCEDURE_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'PROCEDURE' AND STATUS = 'INVALID' THEN STATUS END AS PROCEDURE_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'PACKAGE' AND STATUS = 'VALID' THEN STATUS END AS PACKAGE_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'PACKAGE' AND STATUS = 'INVALID' THEN STATUS END AS PACKAGE_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'PACKAGE BODY' AND STATUS = 'VALID' THEN STATUS END AS PACKAGE_BODY_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'PACKAGE BODY' AND STATUS = 'INVALID' THEN STATUS END AS PACKAGE_BODY_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'LOB' AND STATUS = 'VALID' THEN STATUS END AS LOB_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'LOB' AND STATUS = 'INVALID' THEN STATUS END AS LOB_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'TRIGGER' AND STATUS = 'VALID' THEN STATUS END AS TRIGGER_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'TRIGGER' AND STATUS = 'INVALID' THEN STATUS END AS TRIGGER_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'DATABASE LINK' AND STATUS = 'VALID' THEN STATUS END AS DBLINK_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'DATABASE LINK' AND STATUS = 'INVALID' THEN STATUS END AS DBLINK_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'MVIEW' AND STATUS = 'VALID' THEN STATUS END AS MVIEW_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'MVIEW' AND STATUS = 'INVALID' THEN STATUS END AS MVIEW_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'TABLE PARTITION' AND STATUS = 'VALID' THEN STATUS END AS TABLE_PART_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'TABLE PARTITION' AND STATUS = 'INVALID' THEN STATUS END AS TABLE_PART_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'INDEX PARTITION' AND STATUS = 'VALID' THEN STATUS END AS INDEX_PART_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'INDEX PARTITION' AND STATUS = 'INVALID' THEN STATUS END AS INDEX_PART_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'LOB PARTITION' AND STATUS = 'VALID' THEN STATUS END AS LOB_PART_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'LOB PARTITION' AND STATUS = 'INVALID' THEN STATUS END AS LOB_PART_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'TABLE SUBPARTITION' AND STATUS = 'VALID' THEN STATUS END AS TABLE_SUBPART_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'TABLE SUBPARTITION' AND STATUS = 'INVALID' THEN STATUS END AS TABLE_SUBPART_STAT_INVAL
             , CASE WHEN OBJECT_TYPE = 'INDEX SUBPARTITION' AND STATUS = 'VALID' THEN STATUS END AS INDEX_SUBPART_STAT_VAL
             , CASE WHEN OBJECT_TYPE = 'INDEX SUBPARTITION' AND STATUS = 'INVALID' THEN STATUS END AS INDEX_SUBPART_STAT_INVAL
          FROM DBA_OBJECTS
         WHERE OBJECT_TYPE IN ('TABLE'
                            , 'INDEX'
                            , 'VIEW'
                            , 'SYNONYM'
                            , 'SEQUENCE'
                            , 'FUNCTION'
                            , 'PROCEDURE'
                            , 'PACKAGE'
                            , 'PACKAGE BODY'
                            , 'LOB'
                            , 'TRIGGER'
                            , 'DATABASE LINK'
                            , 'MVIEW'
                            , 'TABLE PARTITION'
                            , 'INDEX PARTITION'
                            , 'LOB PART'
                            , 'TABLE SUBPARTITION'
                            , 'INDEX SUBPARTITION')
           -- AND OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
     ) A
 GROUP BY A.OWNER
 ORDER BY A.OWNER;

-- 22.암호화컬럼정보
SELECT (SELECT MAX(NAME) FROM V$DATABASE) AS "DB명"
     , A.OWNER
     , A.TABLE_NAME AS "테이블명(영문)"
     , B.COMMENTS AS "테이블명(한글)"
     , A.COLUMN_NAME AS "컬럼명(영문)"
     , C.COLUMN_NAME AS "컬럼명(한글)"
     , D.DATA_TYPE AS "DATA TYPE"
  FROM DBA_ENCRYPTED_COLUMNS A
     , DBA_TAB_COMMENTS B
     , DBA_COL_COMMENTS C
     , DBA_TAB_COLS D
 WHERE A.OWNER = B.OWNER
   AND A.TABLE_NAME = B.TABLE_NAME
   AND A.OWNER = C.OWNER
   AND A.TABLE_NAME = C.TABLE_NAME
   AND A.COLUMN_NAME = C.COLUMN_NAME
   AND A.OWNER = D.OWNER
   AND A.TABLE_NAME = D.TABLE_NAME
   AND A.COLUMN_NAME = D.COLUMN_NAME
   -- AND A.OWNER NOT IN (SELECT USERNAME FROM DBA_USERS WHERE ORACLE_MAINTAINED = 'Y')
 ORDER BY A.OWNER, A.TABLE_NAME;